<html>
<head>
	<title>CS 173: Skills list for Examlet E</title>
</head>
<body>
<h1>CS 173: Skills list for &quot;Examlet E&quot;</h1>

<ul>
	<li>Trees
	<ul>
		<li>Define a (full) binary tree recursively: it&#39;s either a single node, or a root with two subtrees children, or (for non-full trees) a root with one subtree child.</li>
		<li>Define and use tree terminology: root, leaf, internal node, parent, child, sibling, (proper) ancestor, (proper) descendent, level of a node, height of tree.</li>
		<li>Define what it means for a tree to be binary, n-ary, or balanced. <em>(The definitions for &quot;full&quot; and&nbsp;&quot;complete&quot; trees will be provided.)</em></li>
		<li>Know key facts: a tree has one more node than edges, a full m-ary tree with i internal nodes has mi+1 nodes total, a full binary tree with n internal nodes has n+1 leaves (and thus 2n+1 nodes total),</li>
		<li>Know key facts about binary trees of height h: the number of leaves is between 1 and 2<sup>h</sup>, the number of nodes is between (h+1) and (2<sup>h+1</sup> - 1)</li>
		<li>Know that the height of a full complete binary tree with n nodes (or n leaves) is approximately log(n).</li>
	</ul>
	</li>
	<li>String notation and regular expressions
	<ul>
		<li>The empty string (&epsilon;)</li>
		<li>Concatenation, *, and | operations</li>
		<li>A<sup>*</sup> is the set of all finite-length strings with characters from A.</li>
		<li>Know what a &quot;bit string&quot; is (a string of one&#39;s and zero&#39;s)</li>
	</ul>
	</li>
	<li>Grammar Trees
	<ul>
		<li>Correctly interpret the definition of a context-free grammar: variables, rules, start symbols, terminal symbols</li>
		<li>Correctly interpret a grammar rule, e.g. what does &epsilon; or a vertical bar mean on the righthand side of a rule.</li>
		<li>Given a grammar G, give examples of trees that are/aren&#39;t generated by G, determine whether a given tree could be generated by G.</li>
		<li>Given a string s and a grammar G, briefly explain why s can/can&#39;t be generated by G.</li>
		<li>Build a tree matching grammar G with a specific terminal string s. When multiple trees are possible, build more than one or describe the set of possible trees.</li>
	</ul>
	</li>
	<li>Tree induction
	<ul>
		<li>Prove a claim about labelled or unlabelled trees using induction.</li>
		<li>Use induction to prove a claim about other sorts of objects, where your induction variable is the size of the object and there may be more than one object of each size.</li>
	</ul>
	</li>
</ul>

<ul>
	<li>Big O
	<ul>
		<li>Define what it means for a function f to be asymptotically smaller than g (f &#8810; g), O(g) and/or &theta;(g). where g is another function.</li>
		<li>For specific functions f and g, identify whether f is asymptotically smaller than g (f &#8810; g), O(g) and/or &theta;(g).</li>
		<li>Know the asymptotic relationships among key primitive functions: constant, log n, n, n log n, polynomials of higher orders, exponentials, factorial.</li>
		<li>Given functions f and g, prove that f is O(g) and/or &theta;(g).</li>
	</ul>
	</li>
	<li>Recursion Trees
	<ul>
		<li>Given a recursively defined function, find its closed form by drawing a recursion tree and adding up the work at all levels. (Examples would look like those presented in the textbook, e.g. the level sums are constant or increase in a pattern based on the key summations given above.)</li>
		<li>Find a big-O solution for a simple recursive definition, of the types that we&#39;ve seen as examples of unrolling and recursion trees.</li>
	</ul>
	</li>
	<li>Algorithms
	<ul>
		<li>Be familiar with the overall structure and big-O running times of the following algorithms.
		<ul>
			<li>merge two sorted lists</li>
			<li>binary search</li>
			<li>merge sort</li>
			<li>graph reachability (what&#39;s in x&#39;s connected component)</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>
</body>
</html>
